\section{Blocked}
\label{chap:design}

\texttt{Blocked} has been designed to be a decentralized system for issuing, sharing and managing digital education certificates thus decentralizing control of access to the information. The system relies on a network of nodes, which maintains the information coherent in every node through consensus algorithms. \texttt{Blocked} relies on the nodes communicating between each other through peer-to-peer mechanisms.

\subsection{Stakeholders}
\label{sec:design-entities}

\texttt{Blocked} is designed to be used by the following stakeholders: \textit{students}, \textit{institutions} and a third entity which we establish as being a \textit{verifiers}. According to the essence of our study, where we present the same high-level stakeholders, with a \textit{verifier} being the \textit{Recruiter}.

\subsection{Technological Architecture}
\label{sec:design-architecture}

In \texttt{Blocked}, each stakeholder is expected to be a node in the network, apart from the \textit{verifier}, for a given period of time. There are two reasons for this: \emph{(i)} each node maintains its own copy of the global state of the network, which means, at least, two nodes \textbf{must} exist at any given time; and \emph{(ii)} in order to manage certificates, one must be connected to the network. At the same time, each peer is both a producer - issuing new transactions - and a validator - because it is a component of the validation network. The network is composed of a collection of nodes. The nodes interact with each other through a peer-to-peer network and maintain the global state by using a consensus algorithm - namely, PoET \cite{intel_poet}. There are two levels to our network. Each node is necessarily a peer in the network but, due to permissioning capabilities of the blockchain, not necessarily a validator node in the network. One might be able to connect to the network as a node, and read information from it, and not be able to validate new blocks because it is not a participant on the validation network. The network allows for information to be shared between all nodes and, at the same time, for nodes to validate on new blocks universally.

We define \textit{state} as the information stored in a particular address of the blockchain. The global state of the system is the collection of all addresses currently maintained, with information, in the blockchain. The global state in \texttt{Blocked} is represented through a Radix Merkle tree. It can be modified by the validator nodes and each node maintains its own copy of the global state. Validator nodes are responsible for ensuring that the global state is the same for all participants in the network. In \texttt{Blocked}, a state entry - an address - consists of the properties \texttt{id}, \texttt{certificate}, \texttt{owners} and \texttt{permissions}. A state entry is stored at a particular address. An address uniquely identifies where information is stored in the global state - i.e. in the Radix Merkle tree. Addressing is done through a process that is deterministic and must respect the following rules: \emph{(i)} An address consists of an hex-encoded string of 70 characters; \emph{(ii)} An address \textbf{must} always start with \emph{"49cb48"}.; and \emph{(iii)} remaining 64 characters of an address \textbf{must} be the first 64 characters of a SHA-512 hash of the certificate property \texttt{id}.

Transactions allow nodes to modify the global state of the system. These are submitted to the validator nodes and processed. If valid, the state is modified. If invalid, the new blocks will be rejected. Transactions are created by the clients in each node. In \texttt{Blocked}, transactions are wrapped in batches, with each batch assumed to have one and only one transaction. Transactions in \texttt{Blocked} allow clients to issue, share and revoke educational certificates.

Controlling access to the information, in \texttt{Blocked} can be achieved in two separate layers. Due to the permissioning nature of the system, we can configure which validator nodes are allowed to modify state in the network. At the same time, there's an access control mechanism above the network layer that is used to guarantee that, even though each node has its own copy of the information, data cannot be correctly read without the relevant permissions. On validator nodes, we can define two separate levels of controlling modification to state: transactor-level and validator-level. At the transactor-level it is possible to control what public keys are allowed to submit batches and transactions. The latter level of permissioning, at the validator-level, allows the configuration of public keys as the only keys that are able to participate in the validation network. Initially, when a certificate is submitted for issuance, the certificate information is encrypted with an AES symmetric key. A new key is generated each time a certificate is submitted and consists of 32 random bytes. Permissions to read the information, stored in the blockchain, are created through encrypting the symmetric key with an asymmetric public key, corresponding to the subject that shall be allowed access. A list of permissions of this type is kept in the blockchain together with the encrypted information.

\subsection{Functional Architecture}
\label{sec:design-interaction}

For a user to use \texttt{Blocked}, it needs to have an identity. Identities are defined in two ways, both with asymmetric cryptography: a DSA-based identity and an RSA-based identity. DSA \cite{cameron_f._kerry_digital_2013} is used for signing the batches and transactions while RSA \cite{rivest_method_1978} is used for encryption of the symmetric key. While RSA \cite{rivest_method_1978} can be used for both encryption and decryption, DSA-based signatures are supported by most blockchain platforms (such as Bitcoin and Ethereum) for signing batches and transactions, which makes it easier for system implementation. In order to run a network, one of the nodes, and only one, should generate a genesis block for the blockchain, as described in the beginning of this chapter. This means that, in broad terms, one of the nodes would have to be responsible for starting the actual network. From that moment on, after other nodes connect, that node will have the same relevance as the remaining nodes.

In \texttt{Blocked}, any user with permission is able to generate a new certificate. For the sake of simplicity, let us call that user an issuer. The following steps should be executed: \emph{(i)} share public keys between issuer and recipient; \emph{(ii)} generate ans submit transaction; \emph{(iii)} validate transaction was committed; and \emph{(iv)} communicate result to recipient.

Revoking a certificate can be accomplished by both the issuer or recipient of a certificate. Both have control to revoke a given certificate. The following steps should be accomplished: \emph{(i)} submit transaction with certificate identifier; and \emph{(ii)} validate transaction was committed and certificate revoked.

One of the main purposes of \texttt{Blocked} is to enable the control of access to the certificates stored in the network. Only the recipient of the certificate has the ability to control the access to certificates and change it. For granting access, the following steps should be executed: \emph{(i)} share public keys between recipient and third-party; \emph{(ii)} submit transaction with encrypted symmetric key and RSA public key shared by the third-party; and \emph{(iii)} validate transaction was committed and communicate. For revoking access, the following steps should be executed: \emph{(i)} submit transaction for access revocation; \emph{(ii)} validate transaction was committed.

Contrary to what has been presented thus far, viewing a certificate does not require the submission of a new transaction to the network. It is not enough to just look at the current state either because the information is encrypted. For a user to view information pertaining to a given certificate, it should identify which address in the network stores the data for that certificate (through the certificate's identifier). It should then proceed to decrypt the existing permissions' list until it can decrypt one of those permissions and obtain the symmetric key. With the symmetric key decrypted, the user should decrypt the certificate's information and will be able to view the certificate.

\subsection{Selected Technologies}
\label{sec:implementation-technology}

The basis of the implementation is Hyperledger Sawtooth. Hyperledger Sawtooth is an open-source effort from The Linux Foundation \cite{linuxfoundation}, that introduces a modular platform for implementation of applications on top of permissioned distributed ledgers. We use it as the backbone of our implementation. \texttt{Blocked} has been developed with the Python \cite{python} programming language. Specifically, the implementation only supports Python 3. Python is a dynamically typed, general-purpose programming language widely popular in software development. It has an established and mature community, with a lot of resources available. Furthermore, Hyperledger Sawtooth provides 3 mature SDK - Python, Go \cite{golang} and JavaScript \cite{nodejs}. From those 3, only Python and Go had a mature Transaction Processor API. With that in mind, Python gives us more flexibility during development, being interpreted rather than compiled, while also providing us with a mature standard library, given it has almost 20 more years of development when compared with Go. Docker is a platform for container execution used for setting up all the components that are needed to run the system can be complex. We used Docker in order to run containers of the Hyperledger Sawtooth infrastructure, in which we could execute our implementation against. This also eases setting up because it doesn't modify any part of the user's system.

\subsection{Developed Components}
\label{sec:implementation-core}

We briefly describe the key components of our implementation. All code can be found on GitHub \cite{blocked}. The several pieces of this implementation, together, fully implement what we propose with the  \texttt{Blocked} system, described previously. Our implementation consists of two main Python packages: \textit{processor} and \textit{blocked}. Both are Python packages, with several modules inside. Apart from that, a collection of executable scripts are provided, with which one could use the packages thus interacting with the blockchain. The Transaction Processor is the component executed together with the validation nodes.

\textbf{Transaction Processor.} As previously explained, the Transaction Processor component connects to the validator running on the user's machine, or running somewhere else. The component has two modules: \texttt{main} and \texttt{handler}. \texttt{main} acts as an interface to start and stop the actual Transaction Processor, whose business logic is written in \texttt{handler}. When running, Transaction Processor will start by verifying an operation has been submitted, followed by determining the certificate address and fetching the existing certificate from state. It will then process the transaction according to what operation has been requested and modify state accordingly.

\textbf{Certificate Issuer.} The Certificate Issuer component is responsible for submitting a new transaction to the validator networks. This component can be found in \texttt{cert\_issuer} and can be executed by running the Python script in \texttt{bin/cert-issuer}. To perform its responsibilities, the script receives the following parameters: Recipient, Secret, Recipient's RSA and Issuer's RSA. With these parameters, the Certificate Issuer will start by generating a new symmetric key to encrypt the data, as well as a new certificate identifier. It will then proceed by generating the payload that will be embedded in the transaction, and batch, to be submitted. It will submit the new transaction and print out both the certificate's identifier and where to check for status of the transaction submission. A user can now validate if the transaction has been accepted. After this point, a certificate with the provided identifier has been generated.

\textbf{Certificate Revoker.} The Certificate Revoker component is responsible for executing the revocation protocol mentioned in Chapter \ref{chap:design}. This component is implemented in module \texttt{cert\_revoker} and can be executed by running the script \texttt{bin/cert-revoker}. It can be executed by passing the following parameters, referencing the actor who is executing it: Certificate, Secret DSA and Secret RSA. The component starts its execution by fetching the relevant certificate from the blockchain. After fetching the certificate, it attempts to decrypt the symmetric key, in order to be able to access the information. If the decryption fails, the component exits with an error. If the decryption is successful, the component creates a payload with the same information but with the property \texttt{active} modified to \texttt{False} - this indicates the certificate is revoked. After generating the new payload, a transaction, and batch, are generated and submitted with the new information. Similarly to what happens with the Certificate Issuer, it will print out where to check for status of the transaction submission.

\textbf{Certificate Access Manager.} The Certificate Access Manager component is responsible for performing the activities of granting and revoking access to a certificate by a particular subject. It can be executed by any user but the transactions will solely be approved if signed by the certificate's recipient. This component can be found in \texttt{access-manager} and can be executed by running the Python script in \texttt{bin/access-manager}. To perform its responsibilities, the script receives the following parameters: Certificate, Subject's DSA, Subject's RSA, Secret DSA, Secret RSA and Remove. The component starts its execution by fetching the relevant certificate from the blockchain. After fetching the certificate, it attempts to decrypt the symmetric key, in order to be able to access the information. If the decryption fails, the component exits with an error. If the decryption is successful, it creates a payload with the access modification operation, submits a new transaction and batch, and prints out where to check for status of the transaction submission. If the transaction is accepted, the permissions are updated, otherwise they will stay the same.

\textbf{Certificate Viewer.} The Certificate Viewer component is responsible solely for displaying certificate information to the user, depending on the correct decryption of the data.  This component can be found in \texttt{cert\_viewer} and can be executed by running the Python script in \texttt{bin/cert-viewer}. To perform its responsibilities, the script receives the following parameters: Certificate, Secret DSA and Secret RSA. The script works by determining the certificate's address and fetching the certificate information, followed by decrypting the symmetric key, through the RSA private key. If decryption fails, it will exit with an error. If the decryption succeeds, it will proceed with decrypting the certificate information and print out its details.

\textbf{Other Utilities.} Apart from the core components, described above, we've implemented other utilities that are necessary in order for the system to be functional. The package \texttt{addressing}, with its module \texttt{addresser}, is shared throughout the other components and contains  information about the transaction details, such as: \emph{(i)} family name to use with Hyperledger Sawtooth, \emph{(ii)} family version that is currently being used and \emph{(iii)} prefix of the addressing scheme. It also contains a shared method for address generation, which is used across components to determine the address for a given certificate. Furthermore, in the module \texttt{utils}, we can find auxiliary methods for a variety of operations.
