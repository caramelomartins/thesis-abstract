\subsection{Selected Technologies}
\label{sec:implementation-technology}

The basis of the implementation is Hyperledger Sawtooth. Hyperledger Sawtooth is an open-source effort from The Linux Foundation \cite{linuxfoundation}, that introduces a modular platform for implementation of applications on top of permissioned distributed ledgers. We use it as the backbone of our implementation. As explained earlier, our approach needs to have a permissioned blockchain, which needs to be customized, to be suitable for our purposes. Hyperledger Sawtooth offers a complete set of tools to build applications on top of a distributed ledger that include: REST API, a validation network infrastructure, permissioning capabilities, events, a consensus protocol - PoET \cite{intel_poet} - and, of course, a blockchain. To connect all the pieces together it offers SDK, in a variety of languages such as Go, Python or JavaScript, easing the development of the implementation.

The implementation of \texttt{Blocked} has been developed with the Python \cite{python} programming language. Specifically, the implementation only supports Python 3. Python is a dynamically typed, general-purpose programming language widely popular in software development. It has an established and mature community, with a lot of resources available. Furthermore, Hyperledger Sawtooth provides 3 mature SDK - Python, Go \cite{golang} and JavaScript \cite{nodejs}. From those 3, only Python and Go had a mature Transaction Processor API. With that in mind, Python gives us more flexibility during development, being interpreted rather than compiled, while also providing us with a mature standard library, given it has almost 20 more years of development when compared with Go.

Docker is a platform for container execution. Setting up all the components that are needed to run the system can be complex. Hyperledger Sawtooth supports Docker files to help with configuration and execution of all the components at the same time. We used Docker in order to run containers of the Hyperledger Sawtooth infrastructure, in which we could execute our implementation against. This also eases setting up because it doesn't modify any part of the user's system.

\subsection{Components}
\label{sec:implementation-core}

We briefly describe the key components of our implementation. All code can be found on GitHub \cite{blocked}. The several pieces of this implementation, together, fully implement what we propose with the  \texttt{Blocked} system, described previously. Our implementation consists of two main Python packages: \textit{processor} and \textit{blocked}. Both are Python packages, with several modules inside. Apart from that, a collection of executable scripts are provided, with which one could use the packages thus interacting with the blockchain. The Transaction Processor is the component executed together with the validation nodes.

\textbf{Transaction Processor.} As previously explained, the Transaction Processor component connects to the validator running on the user's machine, or running somewhere else. The component has two modules: \texttt{main} and \texttt{handler}. \texttt{main} acts as an interface to start and stop the actual Transaction Processor, whose business logic is written in \texttt{handler}. When running, Transaction Processor will start by verifying an operation has been submitted, followed by determining the certificate address and fetching the existing certificate from state. It will then process the transaction according to what operation has been requested and modify state accordingly.

\textbf{Certificate Issuer.} The Certificate Issuer component is responsible for submitting a new transaction to the validator networks. This component can be found in \texttt{cert\_issuer} and can be executed by running the Python script in \texttt{bin/cert-issuer}. To perform its responsibilities, the script receives the following parameters:

\begin{itemize}
	\item Recipient: Recipient's DSA Public Key.
	\item Secret: Issuer's DSA Private key.
	\item Recipient RSA: Path to Recipient's RSA Public Key.
	\item Issuer RSA: Path to Issuer's RSA Public Key.
\end{itemize}

With these parameters, the Certificate Issuer will start by generating a new symmetric key to encrypt the data, as well as a new certificate identifier. It will then proceed by generating the payload that will be embedded in the transaction, and batch, to be submitted. It will submit the new transaction and print out both the certificate's identifier and where to check for status of the transaction submission. A user can now validate if the transaction has been accepted. After this point, a certificate with the provided identifier has been generated.

\textbf{Certificate Revoker.} The Certificate Revoker component is responsible for executing the revocation protocol mentioned in Chapter \ref{chap:design}. This component is implemented in module \texttt{cert\_revoker} and can be executed by running the script \texttt{bin/cert-revoker}. It can be executed by passing the following parameters, referencing the actor who is executing it:

\begin{itemize}
	\item Certificate: Identifier of the certificate to revoke.
	\item Secret DSA: DSA Private Key to validate blockchain identity.
	\item Secret RSA: RSA Private Key to decrypt the information.
\end{itemize}

The component starts its execution by fetching the relevant certificate from the blockchain. After fetching the certificate, it attempts to decrypt the symmetric key, in order to be able to access the information. If the decryption fails, the component exits with an error. If the decryption is successful, the component creates a payload with the same information but with the property \texttt{active} modified to \texttt{False} - this indicates the certificate is revoked. After generating the new payload, a transaction, and batch, are generated and submitted with the new information. Similarly to what happens with the Certificate Issuer, it will print out where to check for status of the transaction submission.

\textbf{Certificate Access Manager.} The Certificate Access Manager component is responsible for performing the activities of granting and revoking access to a certificate by a particular subject. It can be executed by any user but the transactions will solely be approved if signed by the certificate's recipient. This component can be found in \texttt{access-manager} and can be executed by running the Python script in \texttt{bin/access-manager}. To perform its responsibilities, the script receives the following parameters:

\begin{itemize}
	\item Certificate: Identifier of the certificate to revoke.
	\item Subject DSA: DSA Public Key of Subject.
	\item Subject RSA: RSA Public Key of Subject.
	\item Secret DSA: DSA Private Key to validate identity.
	\item Secret RSA: RSA Private Key to decrypt the information.
	\item Remove: If the action to perform is revoking access, instead of granting.
\end{itemize}

The component starts its execution by fetching the relevant certificate from the blockchain. After fetching the certificate, it attempts to decrypt the symmetric key, in order to be able to access the information. If the decryption fails, the component exits with an error. If the decryption is successful, it creates a payload with the access modification operation, submits a new transaction and batch, and prints out where to check for status of the transaction submission. If the transaction is accepted, the permissions are updated, otherwise they will stay the same.

\textbf{Certificate Viewer.} The Certificate Viewer component is responsible solely for displaying certificate information to the user, depending on the correct decryption of the data.  This component can be found in \texttt{cert\_viewer} and can be executed by running the Python script in \texttt{bin/cert-viewer}. To perform its responsibilities, the script receives the following parameters:

\begin{itemize}
	\item Certificate: Identifier of the certificate to revoke.
	\item Secret DSA: DSA Private Key to validate identity.
	\item Secret RSA: RSA Private Key to decrypt the information.
\end{itemize}

The script works by determining the certificate's address and fetching the certificate information, followed by decrypting the symmetric key, through the RSA private key. If decryption fails, it will exit with an error. If the decryption succeeds, it will proceed with decrypting the certificate information and print out the following information:

\begin{itemize}
	\item ID - Identifier of the Certificate;
	\item Issuer - DSA Public Key of Issuer;
	\item Recipient - DSA Public Key of Recipient;
	\item Issuance Date;
	\item Status - Whether the certificate is active or revoked.
\end{itemize}

\textbf{Other Utilities.} Apart from the core components, described above, we've implemented other utilities that are necessary in order for the system to be functional. The package \texttt{addressing}, with its module \texttt{addresser}, is shared throughout the other components and contains  information about the transaction definition (see Chapter \ref{chap:design}), such as: \emph{(i)} family name to use with Hyperledger Sawtooth, \emph{(ii)} family version that is currently being used and \emph{(iii)} prefix of the addressing scheme. It also contains a shared method for address generation, which is used across components to determine the address for a given certificate. Furthermore, in the module \texttt{utils}, we can find auxiliary methods for:

\begin{itemize}
	\item submitting a batch (\texttt{submit\_batch(data)});
	\item fetching certificate information (\texttt{fetch\_state(certificate\_address)});
	\item creating batches (\texttt{make\_batch(txn, signer)});
	\item creating transactions (\texttt{make\_transaction(payload, signer, inputs, outputs)});
	\item encrypting and decrypting, with both AES and RSA.
\end{itemize}
